# 俄罗斯方块

## 游戏介绍

### 组成元素

- 容器

  > 由 20 \* 12 的格子矩阵组成

- 方块

  > 由 4 \* 4 的格子矩阵组成

- 格子

  > 正方形格子，有不同颜色和边框

### 游戏规则

- 方块池拥有多个随机产生的方块，方块最大数量为玩家总数，最少三个，多玩家共用
- 每个玩家都可以从方块池中按方块产生顺序取出一个方块当做操作方块
- 操作方块可以进行顺时针旋转、左移、右移、下落四种操作
- 每个玩家同一时间只能操作一个方块
- 操作方块每间隔一定时间会自然下落一格，自然下落时间间隔随玩家游戏等级提高逐渐缩短
- 操作方块触底或者挨到容器内已有方块无法继续自然下落后玩家失去当前操作方块控制权
- 容器内任意一行如果全部被方块占据将会清空，并且被清空行上方所有行会整体自然下落一格
- 容器内触发清空行为时，玩家得分，在一个时间节点同时清空多行时得分呈指数递增
- 游戏等级随玩家累计清空行数增加而增加
- 操作方块取出时位于与容器顶部中间位置，如果与容器内其他方块产生重叠则游戏结束
- 游戏结束后玩家成绩按各自得分由高到低排名
- 得分一样的按消除行数由低到高排名
- 消除行数也一样的按游戏结束时间有后到先排名

### 操作方式

#### 普通玩家

定义 5 个键位分别控制旋转、左移、右移、下落、暂停

#### AI 玩家

每次从方块池取出操作方块时在一秒内计算出所有操作步骤，然后按顺序执行操作，每执行完一个操作需要间隔 100 毫秒再执行下一个操作

## 实现思路

### 容器

由二维数组组成，数组元素为数字，对应不同方块类型，0 表示无方块
页面上生成容器格子总数量的 DIV，根据当前格子的数值计算 DIV 的颜色和边框样式

### 方块

方块其实可以看做一个缩小版的容器，但是多出了类型、位置、方向几个属性
不同类型的方块数值不同，对于不同的颜色
玩家可以控制方块在容器中的位置，所以需要记录方块坐标
方块发生旋转后方向就随之变化，设置方向时也会旋转相应次数

## 技术点

### Typescript

ts 是强类型版本的 js ，每个变量每个属性的类型都是固定的，适用于逻辑缜密的场景使用，做游戏使用 ts 最适合不过了
class 就相当于定义了不同属性的 object 对象，在 js 中 object 对象的属性是可以随时任意修改的，在 class 中则需要预先定义好
constructor 就是 new 对象时进行初始化操作的构造器
getter 是对象属性的访问器，通过操作符访问对象中的属性时实际上就是调用了属性的 get 方法，getter 固定无入参，必须返回属性同类型的值
setter 是对象属性的设置器，通过操作符设置对象中的属性值实际上就是调用了属性的 set 方法，setter 固定只有一个与属性同类型的入参，无返回值
static 是 class 的静态属性\方法，可以直接通过类名访问而不需要有实际对象，例如 Date.now()，Number.NaN 等

### requestAnimationFrame

这是 window 对象上的全局方法，会在尽可能短的时间内执行传递给它的回调函数，以此形成递归不会因为调用频率过高导致主线程崩溃或者递归过深栈溢出

### Symbol

es6 中的原始数据类型之一，用于表示独一无二的值，即使入参相同也会返回不相等的值
当一个对象中有一个属性，只想在对象内部能够修改外界不允许修改只能访问的时候就可以使用 Symbol 类型来作为属性名

```
const _direction = Symbol('direction');

export class Shape {
	[_direction]: number;
	get direction(): number {
        	return this[_direction];

    	}
	set direction(num: number) {
        	while (this[_direction] !== num) {
			this.transform();
		}
    	}
	transform(){
		this[_direction]++;
		// ...旋转操作代码
	}
}
```

如上所示，实现了可以自由获取方块当前的方向，设置方向的时候也可以旋转对应次数，确保旋转次数和方块方向始终保持一致
如果不使用这种方式，可能会存在方块方向修改了但是实际却没有发生旋转行为

### Worker

众所周知，js 是单线程的，但是却可以使用 Worker 进行异步计算而不阻塞页面主线程，直译“打工人”

~~当老大忙不过来的时候就可以多招几个打工人帮他打工，老大通过禅道给打工人派任务，打工人做完了就在钉钉写个日报告诉老大他做完了，做了些啥~~
~~等老大榨取完打工人的剩余价值之后就可以一脚打打工人踹了，或者暂时留着下次有啥活在叫打工人去干，打工人有时候也会因为干活太慢了被干掉~~

主线程通过调用 Worker 实例的 postMessage 方法发送数据，监听 message 事件获取数据
Worker 通过监听 self 的 message 事件接收主线程发送的数据，调用 self 的 postMessage 方法发送数据给主线程
主线程在收到 Worker 的数据后可以选择调用 Worker 实例的 terminate 方法终止其运行

## 算法相关

### 矩阵旋转

数组是多个元素的集合，也叫一维数组
如果数组中的元素也是数组，就叫做二维数组
如果数组中的元素是二维数组，就是三维数组
每个元素相当于一个点，点动成线，线动成面，面动成体

矩阵是特殊的二维数组，其中的每个一维数组长度都是一样的，把数据排列起来就是一个矩形
旋转其实就是元素顺序重新排列，每一行的数据换成每列对应位置的元素的反转集合
例如第一行的数据换成每列的第一个元素集合然后反转一下，第二行换成每列的第二个元素集合然后反转一下

```
旋转前：			旋转后：
[1,1,2,2]		[1,1,1]
[1,1,2,2]		[1,1,1]
[1,1,2,2]		[2,2,2]
			[2,2,2]
```

### 机器人算法

机器人在计算操作步骤之前，需要算出方块放在哪里最好，但是代码不知道什么叫最好的位置，所以需要量化一下
可以从空洞数量、障碍数量、方块位置、得分这四个纬度进行数据分析：空洞数量越少越好，障碍越少越好，位置越低越靠边越好，得分越高越好
然后就是穷举方块所有可能放置的位置和方向逐一计算得分，优先选择得分高的方案执行，如果执行过程受到阻碍则尝试下一个方案

### 空洞算法

空洞的定义是方块塞不进去的区域，后续方块到达不了就无法清空空洞所在行，接下来把空洞的定义用代码实现

- 如果一个格子上下左右都不是空的那么它就肯定是一个空洞
- 如果周围四个格子有空的，则把当前格子记录下来当备胎，递归遍历周围空的格子算是否为空洞
- 递归过程中，如果空格子已经被标记为备胎了就不把他当空格子
- 递归过程中，如果空格子已经被标记为不是空洞，则所有备胎都转正，标记为不是空洞，结束递归
- 递归过程中，如果空格子已经被标记为是空洞，则所有备胎全部一脚踹掉，标记为是空洞，结束递归
- 递归过程中，如果空格子所在行全部都是空格子，则将格子标记为不是空洞，转正所有备胎，结束递归
- 递归过程中，发现所有相关空格子都被打上了各种标记后，踹掉所有备胎，标记为是空洞，结束递归
- 递归结束后，记录真正不是空洞的那个格子的位置，如果距离当前格子很远，还是把当前格子当做空洞，因为距离太远方块还是塞不进来

### 障碍算法

从上至下从左至右遍历容器内每一个格子，如果格子不是空的，并且它下面还有空格子，那它就是障碍

### 位置算法

方块是一个小型容器，容器内还有空格子存在，计算方块最高点和最低点及距离中心距离时，需要计算出方块中所有不是空的格子的位置，以确保数据精准
游戏容器是最外层，方块的坐标其实是相对于游戏容器的，方块内部的格子也是有坐标的，那就是每个格子所在行列的下标
将格子行列下标分别加上方块的 xy 轴坐标就是格子相对于容器的坐标了，格子相对于方块的坐标叫做本地坐标，格子相对于游戏容器的坐标就叫做世界坐标

游戏中的坐标系一般是以屏幕左上方为原点，水平方向是 X 轴，垂直方向是 Y 轴，越靠近屏幕右侧 X 越大，越靠近屏幕底部 Y 越大

方块内格子的世界坐标，y 坐标最小的就是最高点，y 坐标最大的就是最低点，x 坐标离 X 轴中间最小的就是距离中心位置距离
